local CoroutineLib     = require("util/CoroutineLib")
local DeckLib          = require("util/DeckLib")
local GUIDReferenceApi = require("core/GUIDReferenceApi")
local PlayAreaApi      = require("playarea/PlayAreaApi")
local MythosAreaApi    = require("mythos/MythosAreaApi")
local LocationLib      = require("LocationLib")


local WIND_CARD_GUID_EASTERN = "682cd3"
local WIND_CARD_GUID_WESTERN = "82b859"
local STAR_SPAWNS            = "929cf9"
local CENTRAL_SPIRE_NAME     = "Central Spire"
local FLOATING_SPIRE_NAME    = "Floating Spire"
local OPEN_SKIES_DECK_NAME   = "Open Skies"
local SUMMIT_DECK_NAME       = "Summit Deck"
local RLYEH_STREETS          = "37868c"
local FLOATING_SPIRE_GUID    = "638756"
local ANCIENT_DOME_GUID      = "862f49"
local WESTERN_WALL_GUID      = "ec0fc1"

local AERIAL_WATERFALL_GUID  = "b10b6a"
local aboveTrash             = nil


local BAG_GUIDS                         = {
  ["EASTERN"] = "114b54",
  ["WESTERN"] = "e6b84a",
}

local ACT1_LOCATION_POSITIONS           = {
  { x = 0,  y = 0 },
  { x = 1,  y = 1 },
  { x = 1,  y = -1 },
  { x = 2,  y = 1 },
  { x = 2,  y = -1 },
  { x = 2,  y = 0 },
  { x = -1, y = 1 }
}

local ACT2_ALL_POSITIONS                = {
  { x = -2, y = -1 },
  { x = -2, y = 0 },
  { x = -2, y = 1 },
  { x = -1, y = -1 },
  { x = -1, y = 0 },
  { x = -1, y = 1 },
  { x = 0,  y = 1 },
  { x = 0,  y = 0 },
  { x = 0,  y = -1 },
  { x = 1,  y = 1 },
  { x = 1,  y = 0 },
  { x = 1,  y = -1 },
  { x = 2,  y = 1 },
  { x = 2,  y = 0 },
  { x = 2,  y = -1 }
}

local ACT3_ALL_POSITIONS                = {
  { x = -2, y = -1 },
  { x = -2, y = 0 },
  { x = -2, y = 1 },
  { x = -2, y = -2 },
  { x = -1, y = -1 },
  { x = -1, y = 0 },
  { x = -1, y = 1 },
  { x = -1, y = -2 },
  { x = 0,  y = 1 },
  { x = 0,  y = 0 },
  { x = 0,  y = -1 },
  { x = 0,  y = -2 },
  { x = 1,  y = 1 },
  { x = 1,  y = 0 },
  { x = 1,  y = -1 },
  { x = 1,  y = -2 },
  { x = 2,  y = 1 },
  { x = 2,  y = 0 },
  { x = 2,  y = -1 },
  { x = 2,  y = -2 }
}

local ACT2_INITIAL_SPIRE                = { x = -2, y = 0 }

local ACT3_INITIAL_SPIRE                = { x = -2, y = 1 }

local ACT2_OPEN_SKIES_INITIAL_POSITIONS = {
  { x = -2, y = -1 },
  { x = -1, y = 1 },
  { x = 0,  y = 0 },
  { x = 2,  y = 1 },
  { x = 2,  y = -1 }
}

local ACT3_OPEN_SKIES_INITIAL_POSITIONS = {
  { x = -2, y = 0 },
  { x = -1, y = 1 },
  { x = -1, y = -1 },
  { x = 0,  y = -2 },
  { x = 0,  y = 1 }
}

local RIGHTWARDS_WIND_ARROWS            = {
  { x = 0.5,  y = 1 },
  { x = 1.5,  y = 1 },
  { x = -0.5, y = 1 },
  { x = 0.5,  y = -1 },
  { x = 1.5,  y = -1 },
  { x = -0.5, y = -1 },
}

local LEFTWARDS_WIND_ARROWS             = {
  { x = 0.5,  y = 0 },
  { x = 1.5,  y = 0 },
  { x = -0.5, y = 0 },
}

function onSave()
  return JSON.encode({
    currentAct = currentAct,
    expeditionDirection = expeditionDirection
  })
end

function loadFromSaveTable(savedData)
  for var, val in pairs(JSON.decode(savedData)) do
    _G[var] = val
  end
end

function onLoad(savedData)
  if savedData and savedData ~= "" then
    loadFromSaveTable(savedData)
  else
    currentAct = 0
    expeditionDirection = nil
  end

  local trash = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "Trash")
  if not trash then
    log('Error onLoad. Trash not found.')
    return
  end

  self.addContextMenuItem("Set Act 2", setAct)
  aboveTrash = trash.getPosition() + Vector(0, 1, 0)

  if currentAct == 0 then
    self.createButton({
      label          = "The expedition headed west. (Setup v.I)",
      click_function = "act1SetupWest",
      function_owner = self,
      position       = { 0, 0.11, -0.5 },
      height         = 150,
      width          = 1800,
      scale          = { x = 2, y = 2, z = 2 },
      font_color     = { r = 0, g = 0, b = 0 },
      color          = { r = 1, g = 1, b = 1 }
    })

    self.createButton({
      label          = "The expedition headed east. (Setup v.II)",
      click_function = "act1SetupEast",
      function_owner = self,
      position       = { 0, 0.11, 0.5 },
      height         = 150,
      width          = 1800,
      scale          = { x = 2, y = 2, z = 2 },
      font_color     = { r = 0, g = 0, b = 0 },
      color          = { r = 1, g = 1, b = 1 }
    })
  elseif currentAct == 1 then
    self.createButton({
      label          = "Advance to act II",
      click_function = "act2Setup",
      function_owner = self,
      position       = { 0, 0.11, 0 },
      height         = 150,
      width          = 1800,
      scale          = { x = 2, y = 2, z = 2 },
      font_color     = { r = 0, g = 0, b = 0 },
      color          = { r = 1, g = 1, b = 1 }
    })
  elseif currentAct == 2 then
    self.createButton({
      label          = "Destroy this",
      click_function = "destroy",
      function_owner = self,
      position       = { 0, 0.11, 0 },
      height         = 150,
      width          = 1800,
      scale          = { x = 2, y = 2, z = 2 },
      font_color     = { r = 0, g = 0, b = 0 },
      color          = { r = 1, g = 1, b = 1 }
    })
  end
end

-- Advancing acts

function act1SetupEast(_, color)
  -- function to be called by a button
  act1SetupGeneric('eastern')
end

function act1SetupWest(_, color)
  -- function to be called by a button
  act1SetupGeneric('western')
end

function act1SetupGeneric(param)
  expeditionDirection = param
  if param ~= 'western' and param ~= 'eastern' then
    return
  end

  if currentAct ~= 0 then
    broadcastToAll('NOT IMPLEMENTED')
    return
  end

  function coroutineact1SetupGeneric()
    local escape = false
    -- Step 0. Find pieces.
    escape = areDecksUnavailable()
    if escape then return end
    local summitDeck = getObjectByName(SUMMIT_DECK_NAME)
    local openSkiesDeck = getObjectByName(OPEN_SKIES_DECK_NAME)

    -- Step 1
    -- Place fixed cards
    if expeditionDirection == 'eastern' then
      bag = getObjectFromGUID(BAG_GUIDS['EASTERN'])
    elseif expeditionDirection == 'western' then
      bag = getObjectFromGUID(BAG_GUIDS['WESTERN'])
    else
      -- Implementation error
      return
    end

    if #bag.getObjects() > 0 then
      bag.call("buttonClick_place")
    end

    -- Step 1.5 object existence
    -- Find the the summit deck and the extra open skies
    summitDeck = getObjectByName(SUMMIT_DECK_NAME)
    openSkiesDeck = getObjectByName(OPEN_SKIES_DECK_NAME)
    if not summitDeck then
      printToAll("The Summit deck was not found.", "Red")
      return
    elseif not openSkiesDeck then
      printToAll("The Open Skies deck was not found.", "Red")
      return
    end

    -- Step 2.
    -- Place the Summit deck and the extra Open Akies somewhere safe in the topleft corner area
    DeckLib.placeOrMergeIntoDeck(summitDeck, PlayAreaApi.gridToWorld({ x = -2, y = 2 }), { x = 0, y = 270, z = 180 },
      false, false,
      true)
    printToAll('Summit deck was placed. Rlyeh streets was placed.')
    CoroutineLib.yieldSeconds(0.25)
    DeckLib.placeOrMergeIntoDeck(openSkiesDeck, PlayAreaApi.gridToWorld({ x = -1, y = 2 }), { x = 0, y = 270, z = 180 },
      false, false, true)
    CoroutineLib.yieldSeconds(0.25)
    summitDeck.shuffle()
    CoroutineLib.yieldSeconds(0.25)

    -- Step 3.
    -- Place starting location cards for the act 1. Those are always seven cards.
    for i = 1, 7 do
      summitDeck.takeObject({ position = PlayAreaApi.gridToWorld(ACT1_LOCATION_POSITIONS[i]) })
    end
    printToAll('Locations placed in the grid .')

    -- Step 4.
    -- Shuffle spire on the top three cards
    local spire = getObjectFromGUID("a58106")
    DeckLib.shuffleIntoTopOrBottomX(spire, summitDeck, false, 3, true)
    printToAll('Spire shuffled in the top three cards.')

    currentAct = 1 -- This symbolize that we are in act 1

    -- Step 5.
    -- Move minicards to starting position
    moveMiniCardSomewhere({ position = PlayAreaApi.gridToWorld({ x = -1.2, y = -1.2 }) })
    printToAll('Each investigator begins play at Râ€™lyeh Streets.')

    -- Find the Winds card
    local windCard = nil
    if expeditionDirection == 'western' then
      windCard = getObjectFromGUID(WIND_CARD_GUID_WESTERN)
    elseif expeditionDirection == 'eastern' then
      windCard = getObjectFromGUID(WIND_CARD_GUID_EASTERN)
    end

    -- Place the Winds card accordingly
    if not windCard then
      printToAll('Wind card was not found.')
    else
      if expeditionDirection == 'western' then
        if not windCard.is_face_down then
          windCard.flip()
          CoroutineLib.yieldSeconds(0.25)
        end
        printToAll('Eastern Winds side faceup.')
      elseif expeditionDirection == 'eastern' then
        printToAll('Western Winds side faceup.')
      end
    end

    -- Place Act and Agenda. They are already placed.
    if expeditionDirection == 'western' then
      printToAll('Agenda and Act placed. There are three acts.')
    elseif expeditionDirection == 'eastern' then
      printToAll('Agenda and Act placed. There are two acts.')
    end

    -- Place beautiful but discrete arrows to simbolize wind directions
    for _, posgrid in ipairs(RIGHTWARDS_WIND_ARROWS) do
      local pos = PlayAreaApi.gridToWorld(posgrid)
      drawArrowHead(pos, { 0.3, 0.3, 0.5 }, 1, 'right')
    end
    for _, posgrid in ipairs(LEFTWARDS_WIND_ARROWS) do
      local pos = PlayAreaApi.gridToWorld(posgrid)
      drawArrowHead(pos, { 0.3, 0.5, 0.3 }, 1, 'left')
    end

    -- Remove two starspawns from the game
    local starspawnDeck = getObjectFromGUID(STAR_SPAWNS)
    if starspawnDeck then
      starspawnDeck.shuffle()
      CoroutineLib.yieldSeconds(0.25)
      if expeditionDirection == 'western' then
        starspawnDeck.takeObject({ position = aboveTrash })
        CoroutineLib.yieldSeconds(0.25)
        starspawnDeck.takeObject({ position = aboveTrash })
        printToAll('Two random star spawns were removed.')
      elseif expeditionDirection == 'eastern' then
        starspawnDeck.takeObject({ position = aboveTrash })
        CoroutineLib.yieldSeconds(0.25)
        starspawnDeck.takeObject({ position = aboveTrash })
        CoroutineLib.yieldSeconds(0.25)
        starspawnDeck = takeObjectReturnDeckOrRemainder(starspawnDeck, { position = aboveTrash })
        printToAll('Three random star spawns were removed.')
      end
      CoroutineLib.yieldSeconds(0.25)
      DeckLib.placeOrMergeIntoDeck(starspawnDeck, MythosAreaApi.getEncounterDeckPosition(),
        { x = 0, y = 270, z = 180 },
        false, false, true)
    else
      printToAll('Star Spawn encounter set not found in the table.')
    end

    printToAll('If the creature was defeated, remove the encounter set. Otherwise, spawn the Inescapable.')
    printToAll('Each player takes one Artifact or Item from the expedition.')
    printToAll('Shuffle the encounter deck. You are ready to begin.')
  end

  function coroutineTransformIntoAct2()
    self.removeButton(0)
    self.removeButton(1)
    currentAct = 1
    self.createButton({
      label          = "Advance to act II",
      click_function = "act2Setup",
      function_owner = self,
      position       = { 0, 0.11, 0 },
      height         = 150,
      width          = 1800,
      scale          = { x = 2, y = 2, z = 2 },
      font_color     = { r = 0, g = 0, b = 0 },
      color          = { r = 1, g = 1, b = 1 }
    })
  end

  function coroutineSpawnWindHelper()
    local adventureBag = getObjectFromGUID('5b6dd9')
    if adventureBag then
      adventureBag.takeObject({ position = PlayAreaApi.gridToWorld({ x = 3, y = 2 }), guid = 'fe93af' })
    end
    CoroutineLib.yieldSeconds(0.25)
    local windhelper = getObjectFromGUID('5b6dd9')
    if windhelper then
      windhelper.setVar('actObsidian', currentAct)
      windhelper.setVar('expeditionDirection', expeditionDirection)
    end
  end

  CoroutineLib.start(coroutineact1SetupGeneric)
  CoroutineLib.start(coroutineTransformIntoAct2)
  CoroutineLib.start(coroutineSpawnWindHelper)
end

function act2Setup(_, color)
  function coroutineAct2Setup()
    -- This does this and that
    local escape = false
    local ready = false

    -- Step 0.0
    -- Verify if logic is correct
    if expeditionDirection ~= 'western' and expeditionDirection ~= 'eastern' then
      log('The expeditionDirection variable failed.')
      escape = true
    end
    if currentAct ~= 1 then
      log('The currentAct variable failed.')
      escape = true
    end

    -- Step 0.1. Are the decks available?
    escape = areDecksUnavailable()
    if escape then return end
    local summitDeck = getObjectByName(SUMMIT_DECK_NAME)
    local openSkiesDeck = getObjectByName(OPEN_SKIES_DECK_NAME)

    -- Step 0.2
    -- Verify if the spire is visible
    ready = verifyExistenceAndVisibilityOfLocation({ name = CENTRAL_SPIRE_NAME })
    if not ready then
      printToAll("You cant advance, since you haven't found the Central Spire.", 'Red')
      return
    end

    -- Step 1. Remove Streets
    local rlyehStreets = getObjectFromGUID(RLYEH_STREETS)
    if not rlyehStreets then
      printToAll("R'lyeh Streets was not found", 'Red')
      return
    end
    moveSafely(rlyehStreets, aboveTrash)
    printToAll("R'lyeh Streets was removed", 'White')

    -- Step 2.
    -- Take almost all remaining locations and openskies and place them on the Summit deck
    log('200')
    local locationsToMove = findLocationsToMoveExcept(ACT2_ALL_POSITIONS, CENTRAL_SPIRE_NAME)
    log('201')
    shuffleManyThingsInDeckSafely(locationsToMove, summitDeck)
    log('202')
    CoroutineLib.yieldSeconds(0.25)
    printToAll('Locations shuffled into the Summit deck.', 'White')
    printToAll('Make sure to clean manually any remaining token.', 'White')
    log('203')

    -- Step 3. Place locations in the new shape

    -- Step 3.1 Placing the Central Spire in the correct space
    spire = getObjectByName(CENTRAL_SPIRE_NAME)
    moveSafely(spire, PlayAreaApi.gridToWorld(ACT2_INITIAL_SPIRE))
    if spire.is_face_down then
      spire.flip()
      CoroutineLib.yieldSeconds(0.25)
    end

    -- Step 3.2
    -- Move minicards to starting position
    local position = PlayAreaApi.gridToWorld(ACT2_INITIAL_SPIRE) + Vector(0.5, 0, 0)
    moveMiniCardSomewhere({ position = position })

    -- Step 3.3. Place five Open Skies
    for _, coords in ipairs(ACT2_OPEN_SKIES_INITIAL_POSITIONS) do
      openSkiesDeck.takeObject({ position = PlayAreaApi.gridToWorld(coords) })
      CoroutineLib.yieldSeconds(0.25)
    end

    -- Step 3.4.
    local freePlaces = exclude_pairs(ACT2_ALL_POSITIONS, ACT2_OPEN_SKIES_INITIAL_POSITIONS)
    freePlaces = exclude_pairs(freePlaces, { ACT2_INITIAL_SPIRE })
    for i, coords in ipairs(freePlaces) do
      summitDeck.takeObject({ position = PlayAreaApi.gridToWorld(coords) })
      CoroutineLib.yieldSeconds(0.25)
    end

    -- Step 4. Shuffle two cards on top
    local chest = MythosAreaApi.getSetAsideChest()
    if not chest then
      return
    end

    chest.takeObject({
      guid = AERIAL_WATERFALL_GUID,
      position = PlayAreaApi.gridToWorld({ x = 2.1, y = -2.1 })
    })
    local aerial = getObjectFromGUID(AERIAL_WATERFALL_GUID)
    CoroutineLib.yieldSeconds(0.25)

    local secondThing = nil
    if expeditionDirection == 'eastern' then
      chest.takeObject({
        guid = ANCIENT_DOME_GUID,
        position = PlayAreaApi.gridToWorld({ x = 2.3, y = -2.3 })
      })
      secondThing = getObjectFromGUID(ANCIENT_DOME_GUID)
      CoroutineLib.yieldSeconds(0.24)
    else
      chest.takeObject({
        guid = FLOATING_SPIRE_GUID,
        position = PlayAreaApi.gridToWorld({ x = 2.3, y = -2.3 })
      })
      secondThing = getObjectFromGUID(FLOATING_SPIRE_GUID)
      CoroutineLib.yieldSeconds(0.24)
    end

    local couple = { aerial, secondThing }

    if not aerial or not secondThing then
      log('Error in the last step. Taking the two locations out of the bag.')
      printToAll('Please, shuffle the two locations manually.')
      return
    end

    CoroutineLib.yieldSeconds(0.10)
    DeckLib.shuffleIntoTopOrBottomX(couple, summitDeck, false, 3, true)
    printToAll('Two locations were shuffled with the top three cards of the Summit deck.')
    printToAll('You can continue playing.')

    currentAct = 2
    -- Transform this helper into Act II helper
    self.removeButton(0)
    if expeditionDirection == 'western' then
      self.createButton({
        label          = "Advance to act III.",
        click_function = "act3Setup",
        function_owner = self,
        position       = { 0, 0.11, 0 },
        height         = 150,
        width          = 1800,
        scale          = { x = 2, y = 2, z = 2 },
        font_color     = { r = 0, g = 0, b = 0 },
        color          = { r = 1, g = 1, b = 1 }
      })
    else
      self.createButton({
        label          = "Advance to act III.",
        click_function = "noAct3",
        function_owner = self,
        position       = { 0, 0.11, 0 },
        height         = 150,
        width          = 1800,
        scale          = { x = 2, y = 2, z = 2 },
        font_color     = { r = 0, g = 0, b = 0 },
        color          = { r = 1, g = 1, b = 1 }
      })
    end
  end

  CoroutineLib.start(coroutineAct2Setup)
end

function act3Setup(_, color)
  function coroutineAct3Setup()
    local escape = false
    local ready = false

    -- Step 0.0
    -- Verify if logic is correct
    if expeditionDirection ~= 'western' and expeditionDirection ~= 'eastern' then
      log('The expeditionDirection variable failed.')
      escape = true
    end
    if currentAct ~= 2 then
      log('The currentAct variable failed.')
      escape = true
    end

    -- Step 0.1. Are the decks available?
    escape = areDecksUnavailable()
    if escape then return end
    local summitDeck = getObjectByName(SUMMIT_DECK_NAME)
    local openSkiesDeck = getObjectByName(OPEN_SKIES_DECK_NAME)

    -- Step 0.2
    -- Verify if the Floating Spire is visible
    ready = verifyExistenceAndVisibilityOfLocation({ name = FLOATING_SPIRE_NAME })
    if not ready then
      printToAll("You cant advance, since you haven't found the Floating Spire.", 'Red')
      return
    end

    -- Step 1. Remove Central Spire
    local centralSpire = getObjectByName(CENTRAL_SPIRE_NAME)
    if not centralSpire then
      printToAll("R'lyeh Streets was not found", 'Red')
      return
    end

    centralSpire.setLock(false)
    CoroutineLib.yieldSeconds(0.25)
    DeckLib.placeOrMergeIntoDeck(centralSpire, aboveTrash, { x = 0, y = 270, z = 180 }, false, false, true)
    CoroutineLib.yieldSeconds(0.25)
    printToAll("Central Spire was removed", 'White')

    -- Step 2.
    -- Take almost all remaining locations and openskies and place them on the Summit deck
    local locationsToMove = findLocationsToMoveExcept(ACT2_ALL_POSITIONS, FLOATING_SPIRE_NAME)
    shuffleManyThingsInDeckSafely(locationsToMove, summitDeck)
    CoroutineLib.yieldSeconds(0.25)
    printToAll('Locations shuffled into the Summit deck.', 'White')
    printToAll('Make sure to clean manually any remaining token.', 'White')

    -- Step 3. Place locations in the new shape

    -- Step 3.1 Placing the Floating Spire in the correct space
    local floatingSpire = getObjectByName(FLOATING_SPIRE_NAME)
    moveSafely(floatingSpire, PlayAreaApi.gridToWorld(ACT3_INITIAL_SPIRE))
    if floatingSpire.is_face_down then
      floatingSpire.flip()
      CoroutineLib.yieldSeconds(0.25)
    end

    -- Step 3.2. Move minicards to starting position
    local position = PlayAreaApi.gridToWorld(ACT3_INITIAL_SPIRE) + Vector(0.6, 0, 0)
    moveMiniCardSomewhere({ position = position })

    -- Step 3.3. Place five Open Skies
    for _, coords in ipairs(ACT3_OPEN_SKIES_INITIAL_POSITIONS) do
      openSkiesDeck = takeObjectRobust(openSkiesDeck, { position = PlayAreaApi.gridToWorld(coords) })
      --openSkiesDeck.takeObject()
      CoroutineLib.yieldSeconds(0.25)
    end

    -- Step 3.4. Place 18 cards
    local freePlaces = exclude_pairs(ACT3_ALL_POSITIONS, ACT3_OPEN_SKIES_INITIAL_POSITIONS)
    freePlaces = exclude_pairs(freePlaces, { ACT3_INITIAL_SPIRE })
    for i, coords in ipairs(freePlaces) do
      summitDeck = takeObjectRobust(summitDeck, { position = PlayAreaApi.gridToWorld(coords) })
      -- summitDeck.takeObject({ position = PlayAreaApi.gridToWorld(coords) })
      CoroutineLib.yieldSeconds(0.25)
    end

    local chest = MythosAreaApi.getSetAsideChest()
    if not chest then
      return
    end

    chest.takeObject({
      guid = WESTERN_WALL_GUID,
      position = PlayAreaApi.gridToWorld({ x = 2.3, y = -2.3 })
    })
    local westernWall = getObjectFromGUID(WESTERN_WALL_GUID)
    CoroutineLib.yieldSeconds(0.25)

    if not westernWall then
      log('Error in the last step. Taking the Western wall locations out of the bag.')
      printToAll('Please, shuffle it manually.')
      return
    end

    CoroutineLib.yieldSeconds(0.10)
    DeckLib.shuffleIntoTopOrBottomX(westernWall, summitDeck, false, 3, true)
    printToAll('Western wall was shuffled with the top three cards of the Summit deck.')
    printToAll('You can continue playing.')
  end

  CoroutineLib.start(coroutineAct3Setup)
end

function noAct3(_, color)
  -- function to be called by a button
  if expeditionDirection == 'eastern' then
    printToAll('There is no Act 3 if the expedition headed west.')
  else
    log('logic error')
  end
end

-- MOVER HELPER

function takeObjectReturnDeckOrRemainder(deck, params)
  deck.takeObject(params)
  if deck.remainder == nil then
    return deck
  else
    return deck.remainder
  end
end

function takeObjectRobust(deck, params)
  if deck.tag == 'Deck' then
    deck = takeObjectReturnDeckOrRemainder(deck, params)
  elseif deck.tag == 'Card' then
    deck.setPosition(params)
  end
  return deck
end

function moveSafely(obj, location)
  obj.setLock(false)
  CoroutineLib.yieldSeconds(0.11)
  DeckLib.placeOrMergeIntoDeck(obj, location, { x = 0, y = 270, z = 180 }, false, false, true)
  CoroutineLib.yieldSeconds(0.25)
end

function shuffleManyThingsInDeckSafely(tableo, deck)
  local aboveDeck = deck.getPosition() + Vector(0, 0.8, 0)
  for _, obj in ipairs(tableo) do
    DeckLib.placeOrMergeIntoDeck(obj, aboveDeck, { x = 0, y = 270, z = 180 }, false, false, true)
    CoroutineLib.yieldSeconds(0.20)
  end

  CoroutineLib.yieldSeconds(1)
  deck.shuffle()
  CoroutineLib.yieldSeconds(0.20)
end

-- HELPER

function getObjectByName(name)
  for _, obj in ipairs(getObjects()) do
    if obj.getName() == name then
      return obj
    end
  end
end

function drawArrowHead(pos, color, size, direction)
  local thickness = 0.1
  allLines = Global.getVectorLines() or {}
  if direction == "right" then
    p1 = { x = pos.x, y = pos.y, z = pos.z - size }
    p2 = { x = pos.x + size, y = pos.y, z = pos.z + size }
    p3 = { x = pos.x - size, y = pos.y, z = pos.z + size }
  elseif direction == "left" then
    p1 = { x = pos.x, y = pos.y, z = pos.z + size }
    p2 = { x = pos.x + size, y = pos.y, z = pos.z - size }
    p3 = { x = pos.x - size, y = pos.y, z = pos.z - size }
  else
    log('invalid direction for arrowhead')
    return
  end

  table.insert(allLines, { points = { p1, p2 }, color = color, thickness = thickness })
  -- table.insert(allLines, { points = { p2, p3 }, color = color, thickness = thickness })
  table.insert(allLines, { points = { p3, p1 }, color = color, thickness = thickness })

  Global.setVectorLines(allLines)
end

function isLocationOrOpenSkies(obj)
  local rawNotes = obj.getGMNotes() or "{}"
  local md = JSON.decode(rawNotes) or {}
  local type = md['type'] or ''
  return type == 'Location' or obj.getName() == 'Open Sky'
end

local function same_pos(a, b)
  return a.x == b.x and a.y == b.y
end

function exclude_pairs(listA, listB)
  local result = {}

  for _, a in ipairs(listA) do
    local found = false
    for _, b in ipairs(listB) do
      if same_pos(a, b) then
        found = true
        break
      end
    end
    if not found then
      table.insert(result, a)
    end
  end

  return result
end

function setAct()
  self.setVar("actObsidian", 1)
end

function moveMiniCardSomewhere(params)
  local minis = getObjectsWithTag("Minicard")
  local delta = params.delta or 0.50
  local destination = params.position
  if not destination or not minis then
    return
  end
  for _, mini in ipairs(minis) do
    destination = destination + Vector(delta, 0, 0)
    mini.setPositionSmooth(destination)
  end
end

function verifyExistenceAndVisibilityOfLocation(params)
  -- This asumes the params make reference to a location card
  local guid = params.guid
  local name = nil
  obj = nil
  if not guid then
    name = params.name
    if not name then
      return
    end
  end

  if guid then
    obj = getObjectFromGUID(guid)
  elseif name then
    obj = getObjectByName(name)
  end

  if not obj then
    return false
  end

  if obj.is_face_down then
    return false
  end

  return true
end

function findLocationsToMoveExcept(tableo, name)
  local locationsToMove = {}
  for _, coords in ipairs(tableo) do
    local found = {}
    found = LocationLib.getObjectsAt(coords)
    for _, obj in ipairs(found) do
      if isLocationOrOpenSkies(obj) then
        if obj.getName() ~= name then
          table.insert(locationsToMove, obj)
        end
      end
    end
  end
  return locationsToMove
end

function areDecksUnavailable()
  -- Very specific function
  local escape = false
  local summitDeck = getObjectByName(SUMMIT_DECK_NAME)
  local openSkiesDeck = getObjectByName(OPEN_SKIES_DECK_NAME)
  if not summitDeck then
    log("The Summit deck was not found.")
    escape = true
  end
  if not openSkiesDeck then
    log("The Open Skies deck was not found.")
    escape = true
  end
  return escape
end
